#include "Navigation.h"

//坐标地图
int Location[AllNodeCount][2] =
{ 873	,	389	,
1081	,	389	,
1179	,	383	,
1198	,	502	,
924	,	529	,
1098	,	472	,
756	,	502	,
558	,	322	,
683	,	319	,
706	,	390	,
1168	,	272	,
1350	,	131	,
1398	,	55	,
1185	,	144	,
908	,	100	,
765	,	127	,
592	,	97	,
592	,	145	,
683	,	239	,
598	,	239	,
536	,	534	,
607	,	534	,
604	,	502	,
775	,	502	,
802	,	467	,
908	,	485	,
923	,	512	,
990	,	529	,
990	,	516	,
1029	,	472	,
1148	,	472	,
1179	,	472	,
1148	,	272	,
1148	,	216	,
1242	,	216	,
1242	,	185	,
1398	,	185	,
1398	,	108	,
1242	,	55	,
1242	,	144	,
1070	,	144	,
1070	,	272	,
1043	,	272	,
1043	,	312	,
852	,	312	,
765	,	312	,
765	,	274	,
751	,	127	,
751	,	97	,
683	,	274	,
579	,	274	,
536	,	274	,
579	,	414	,
706	,	414	,
706	,	400	,
684	,	390	,
734	,	400	,
734	,	461	,
775	,	461	,
820	,	389	,
852	,	389	,
963	,	389	,
963	,	404	,
1029	,	404	,
1081	,	404	,
1350	,	107	,
579	,	239	,
579	,	322,
1179,  502
};
int AdjacentMatrix[AllNodeCount][AllNodeCount] =
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,
0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
int Distance[AllNodeCount][AllNodeCount];//存储最短距离
int Path[AllNodeCount][AllNodeCount]; //存储最短路径 
SA::SA(Strategy s, Car* c, Task* t)
{
	//算法参数
	T0 = 1000;
	T = T0;
	max_iter = 1000;
	Lk = 50;
	alpha = 0.98;
	strategy = s;
	for (int i = 0; i < MaxCarNum; i++)
	{
		car[i] = c[i];
		if (car[i].CarNum != -1 && car[i].Status != OCCUPIED)
		{
			CarNum++;
		}
	}
	for (int i = 0; i < MaxTaskNum; i++)
	{
		task[i] = t[i];
		if (task[i].TaskNum != -1)
		{
			TaskNum++;
		}
	}

	bestallpath = (int**)malloc(sizeof(int) * CarNum);//最佳全部路径序列
	for (int i = 0; i < CarNum; i++)
	{
		bestallpath[i] = (int*)malloc(sizeof(int) * (TaskNum * 2 + CarNum+1));
		for (int j = 0; j < TaskNum * 2 + CarNum+1; j++)
		{
			bestallpath[i][j] = -1;
		}
	}
	//srand((unsigned)time(NULL));
}
SA::~SA()
{}

void SA::InitPath()//初始化运输路径
{

	//通过序列表示运送方法：[2 8]表示一个任务的起点和终点，car[2 8]表示[2 8]任务由一辆车完成。
	//若现有2车和3个任务，则可以通过下述方法表示不同运输分配：
	//car[2 8]car[5 7][6 4]或car[2 8][5 7]car[6 4]等，car分隔开的任务由其前一个car完成
	for (int i = 0; i < CarNum; i++)
	{
		CarIndex[i] = i;
	}
	for (int i = 0; i < TaskNum; i++)
	{
		TaskIndex[i] = CarNum + i;
	}
}

void SA::StartSA()//开始模拟退火
{
	InitPath();
	float Cost0 = CalculateCost(CarIndex, TaskIndex), BestCost, NewCost = 0;
	BestCost = Cost0;
	//printf("T:%f,BestCost:%f\n", T, BestCost);
	memcpy(BestCarIndex, CarIndex, sizeof(CarIndex));
	memcpy(BestTaskIndex, TaskIndex, sizeof(TaskIndex));
	for (int iter = 0; iter < max_iter; iter++)//开始算法迭代
	{
		for (int i = 0; i < Lk; i++)//每个温度的内循环
		{
			NewCost = NewPath(&Cost0);//生成新解并判断
			if (NewCost < BestCost)
			{
				BestCost = NewCost;
				memcpy(BestCarIndex, CarIndex, sizeof(CarIndex));
				memcpy(BestTaskIndex, TaskIndex, sizeof(TaskIndex));
			}
		}
		T = alpha * T;// 温度下降
		//printf("T:%.2f,BestCost:%.2f\n", T, BestCost);
	}
	ShowResult();
}
void SA::ShowResult()
{
	//for (int i = 0; i < CarNum; i++)
	//{
	//	for (int j = 0; bestallpath[i][j] != -1; j++)
	//	{
	//		printf("%d ", bestallpath[i][j]);
	//	}
	//	printf("\n");
	//}
	//printf("\n");
	//for (int i = 0; i < CarNum; i++)
	//{
	//	printf("%d ", BestCarIndex[i]);
	//}
	//printf("\n\n");
	//for (int i = 0; i < TaskNum; i++)
	//{
	//	printf("%d ", BestTaskIndex[i]);
	//}
	//更新路径
	int c = -1, index = 0;
	for (int i = 0; i < CarNum + TaskNum; i++)
	{
		for (int j = 0; j < CarNum; j++)
		{
			if (CarIndex[j] == i)
			{
				c = c + 1;
				index = 0;
				bestallpath[c][index++] = car[j].CarNodeNum;
				break;
			}
		}
		for (int j = 0; j < TaskNum; j++)
		{
			if (TaskIndex[j] == i)
			{
				bestallpath[c][index++] = task[j].StartNum;
				bestallpath[c][index++] = task[j].TargetNum;
				break;
			}
		}
	}
	//打印路径
	//for (int i = 0; i < CarNum; i++)
	//{
	//	for (int j = 0; j < CarNum; j++)
	//	{
	//		if (car[j].CarNodeNum == bestallpath[i][0])
	//		{
	//			printf("第%d辆车的路径为：\t", car[j].CarNum);
	//		}
	//	}
	//	for (int j = 0; bestallpath[i][j] != -1; j++)
	//	{
	//		printf("%d ", bestallpath[i][j]);
	//	}
	//	printf("\n");
	//}
}
float SA::CalculateCost(int carIndex[], int taskIndex[])//代价计算，通过调配策略决定
{
	int index = 0, c = -1;
	int** tempallpath = (int**)malloc(sizeof(int) * CarNum);//最佳全部路径序列
	for (int i = 0; i < CarNum; i++)
	{
		tempallpath[i] = (int*)malloc(sizeof(int) * (TaskNum * 2 + CarNum+1));
		for (int j = 0; j < TaskNum * 2 + CarNum+1; j++)
		{
			tempallpath[i][j] = -1;
		}
	}


	for (int i = 0; i < CarNum + TaskNum; i++)
	{
		for (int j = 0; j < CarNum; j++)
		{
			if (carIndex[j] == i)
			{
				c = c + 1;
				index = 0;
				tempallpath[c][index++] = car[j].CarNodeNum;
				break;
			}
		}
		for (int j = 0; j < TaskNum; j++)
		{
			if (taskIndex[j] == i)
			{
				tempallpath[c][index++] = task[j].StartNum;
				tempallpath[c][index++] = task[j].TargetNum;
				break;
			}
		}
	}

	if (strategy == MINDISTANCE)//最小总路程策略
	{
		float cost = 0;
		for (int i = 0; i < CarNum; i++)
		{
			for (int j = 0;; j++)
			{
				if (tempallpath[i][j + 1] == -1)
				{
					break;
				}
				cost += Distance[(tempallpath[i][j]) - 1][(tempallpath[i][j + 1]) - 1];
			}
		}

		for (int i = 0; i < CarNum; i++)
		{
			free(tempallpath[i]);
		}
		free(tempallpath);

		return cost;
	}
	else//最小时间策略
	{
		float cost[MaxCarNum] = { 0 };
		for (int i = 0; i < CarNum; i++)
		{
			for (int j = 0;; j++)
			{
				if (tempallpath[i][j + 1] == -1)
				{
					break;
				}
				cost[i] += Distance[tempallpath[i][j] - 1][tempallpath[i][j + 1] - 1];
			}
		}
		float maxcost = cost[0];
		for (int i = 0; i < CarNum; i++)
		{
			if (cost[i] > maxcost)
			{
				maxcost = cost[i];
			}
		}

		for (int i = 0; i < CarNum; i++)
		{
			free(tempallpath[i]);
		}
		free(tempallpath);
		return maxcost;
	}
}
float SA::NewPath(float* Cost0)//模拟退火算法生成新解
{
	//p1: 使用目标交换法产生新路径的概率
	//p2 : 使用车辆交换法产生新路径的概率
	//1 - p1 - p2:是使用共同交换产生新路径的概率
	int newcarIndex[MaxCarNum], newtaskIndex[MaxTaskNum];
	memcpy(newcarIndex, CarIndex, sizeof(CarIndex));
	memcpy(newtaskIndex, TaskIndex, sizeof(TaskIndex));
	float p1 = 0.33, p2 = 0.33;
	float p = rand() / (RAND_MAX + 1.0);

	if (p < p1 && TaskNum>1)
	{
		//printf("%f+111\n", p);
		int sw1 = rand() % (TaskNum);
		int sw2 = rand() % (TaskNum);
		int temp;
		temp = newtaskIndex[sw1];
		newtaskIndex[sw1] = newtaskIndex[sw2];
		newtaskIndex[sw2] = temp;
	}
	else if (p < p1 + p2 && CarNum>1)
	{
		//printf("%f+222\n", p);
		int sw1 = rand() % (CarNum);
		int sw2 = rand() % (CarNum);
		int temp;
		temp = newcarIndex[sw1];
		newcarIndex[sw1] = newcarIndex[sw2];
		newcarIndex[sw2] = temp;
	}
	else
	{
		int sw1 = rand() % (TaskNum);
		int sw2 = rand() % (CarNum);
		int temp;
		if (newcarIndex[sw2] != 0)//不能在第一个位置放任务
		{
			//printf("%f+333\n", p);
			temp = newcarIndex[sw2];
			newcarIndex[sw2] = newtaskIndex[sw1];
			newtaskIndex[sw1] = temp;
		}
	}
	float Cost1 = CalculateCost(newcarIndex, newtaskIndex);
	//决定是否更新解
	if (Cost1 < *Cost0)
	{
		*Cost0 = Cost1;
		memcpy(CarIndex, newcarIndex, sizeof(CarIndex));
		memcpy(TaskIndex, newtaskIndex, sizeof(TaskIndex));
	}
	else
	{
		p = rand() / (RAND_MAX + 1.0);//根据Metropolis准则计算一个概率
		if (p < exp(-(Cost1 - *Cost0) / T))//生成一个随机数和这个概率比较，如果该随机数小于这个概率
		{
			*Cost0 = Cost1;
			memcpy(CarIndex, newcarIndex, sizeof(CarIndex));
			memcpy(TaskIndex, newtaskIndex, sizeof(TaskIndex));
		}
	}
	return *Cost0;
}


float CalculateD(float x0, float y0, float x1, float y1)
{
	return sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1));
}

void Floyd() 
{
	int v, w, k;

	for (v = 0; v < AllNodeCount; v++)
		for (w = 0; w < AllNodeCount; w++)
		{
			if (AdjacentMatrix[v][w] == 1)
			{
				Distance[v][w] = CalculateD(Location[v][0], Location[v][1], Location[w][0], Location[w][1]);
			}
			else
			{
				Distance[v][w] = 99999;
			}

			Path[v][w] = w;
		}
	for (k = 0; k < AllNodeCount; k++)
		for (v = 0; v < AllNodeCount; v++)
			for (w = 0; w < AllNodeCount; w++)
			{
				if (Distance[v][w] > Distance[v][k] + Distance[k][w])
				{
					Distance[v][w] = Distance[v][k] + Distance[k][w];
					Path[v][w] = Path[v][k];
				}
			}
	//cout << endl;
	//cout << "路径矩阵为：" << endl;
	//for (int i = 0; i < AllNodeCount; i++)  //打印最短路径矩阵 
	//{
	//	for (int j = 0; j < AllNodeCount; j++)
	//		cout << Path[i][j] << " ";
	//	cout << endl;
	//}
	//for (int i = 0; i < AllNodeCount; i++)  //打印任意两点最短路径 
	//{
	//	for (int j = 0; j < AllNodeCount; j++)
	//	{
	//		if (i == j) continue;
	//		cout << i + 1 << "->" << j + 1 << "的最短距离为:" << Distance[i][j] << endl;
	//		cout << "最短路径为：" << i + 1;
	//		k = Path[i][j];
	//		while (k != j)
	//		{
	//			cout << "->" << k + 1;
	//			k = Path[k][j];
	//		}
	//		cout << "->" << j + 1 << endl;
	//	}
	//}
}
